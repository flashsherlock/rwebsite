---
title: 'ggplot2: Layers'
author: Fei
date: '2021-03-29'
slug: ggplot2-layers
categories:
  - R
tags:
  - plot
  - R
weight: 1
draft: no
output:
  blogdown::html_page:
    toc: yes
    toc_depth: 3
    number_sections: yes
---

```{r include=FALSE}
knitr::opts_chunk$set(warning = F, message = F, cache = TRUE,tidy=F,fig.align='center',fig.showtext=TRUE,results="hold",fig.show = "hold")
library(tidyverse)
library(patchwork)
```

# Introduction

In general, there are three purposes for a layer:

* To display the data. 
* To display a statistical summary of the data. 
* To add additional metadata: context, annotations, and references.

# Geoms
Geoms can be roughly divided into individual and collective geoms. 

* __Individual geoms__ draw a distinct graphical object for each observation (row). For example, the point geom draws one point per row.
  * `geom_bar(stat = "identity")` makes a bar chart. We need stat = "identity" because the default stat automatically counts values
  * `geom_area()` draws an area plot, which is a line plot filled to the y-axis (filled lines).
  * `geom_rect()` draw rectangles (parameterised by the four corners of the rectangle).
  * `geom_tile()` also draw rectangles (parameterised by the center of the rect and its size).
  * `geom_raster()` is a fast special case of `geom_tile()` used when all the tiles are the same size.
* __Collective geoms__ display multiple observations with one geometric object.
  * The assignment of observations to graphical elements can be controlled by `group` aesthetic.
  
```{r fig.height=2, fig.width=4}
library(babynames)
hadley <- dplyr::filter(babynames, name == "Hadley")
ggplot(hadley, aes(year, n, group = sex, color = sex)) + 
  geom_line()
```
  
  * If a group is defined by a **combination of multiple variables**, use `interaction()` to combine them, e.g. `aes(group = interaction(school_id, student_id))`.
  * Setting the grouping aesthetic in `ggplot()` will affect all geoms below.
  * Lines and paths operate on a **“first value” principle**: each segment is defined by two observations, and ggplot2 applies the aesthetic value (e.g., color) associated with the first observation when drawing the segment.
  * Mapping aesthetics to discrete variables works well for bar and area plots, resulting in **stacking** individual pieces.

# Statistical summaries
## Revealing uncertainty
There are four basic families of geoms using the aesthetics `ymin` and `ymax` to show uncertainty:
* Discrete x, range: `geom_errorbar()`, `geom_linerange()`
* Discrete x, range & center: `geom_crossbar()`, `geom_pointrange()`
* Continuous x, range:` geom_ribbon()`
* Continuous x, range & center: `geom_smooth(stat = "identity")`

```{r fig.height=2, fig.width=6}
y <- c(18, 11, 16)
df <- data.frame(x = 1:3, y = y, se = c(1.2, 0.5, 1.0))
base <- ggplot(df, aes(x, y, ymin = y - se, ymax = y + se))
base + geom_crossbar()|
base + geom_pointrange()|
base + geom_smooth(stat = "identity")
```

```{r fig.height=2, fig.width=8}
base + geom_errorbar()|
# if set width of errorbar to 0, it will be same as linerange
base + geom_errorbar(width = 0)|
base + geom_linerange()|
base + geom_ribbon()
```

## Weighted data
Data can be weighted by the `weight` aesthetic.
```{r fig.height=2, fig.width=6}
# Unweighted
ggplot(midwest, aes(percwhite, percbelowpoverty)) + 
  geom_point() + 
  geom_smooth(method = lm, size = 1) |

# Weighted by population
ggplot(midwest, aes(percwhite, percbelowpoverty)) + 
  geom_point(aes(size = poptotal / 1e6)) + 
  geom_smooth(aes(weight = poptotal), method = lm, size = 1) +
  scale_size_area(guide = "none")
```

## Displaying distributions
There are a number of geoms that can be used to display distributions. To compare the distribution between groups, you have a few options: 

* Show small multiples of the histogram, `facet_wrap(~ var)`.
* Use color and a frequency polygon, `geom_freqpoly()`.
* Use a "conditional density plot", `geom_histogram(position = "fill")`.

An alternative to a bin-based visualisation is a density estimate. `geom_density()` places a little normal distribution at each data point and sums up all the curves.
```{r fig.height=6, fig.width=6}
# define layout
layout <- "
AB
CD
EF
"
# Use color and a frequency polygon
ggplot(diamonds, aes(depth)) + 
  geom_freqpoly(aes(colour = cut), binwidth = 0.1, na.rm = TRUE) +
  theme(legend.position = "none") +
# Use a "conditional density plot"
ggplot(diamonds, aes(depth)) + 
  geom_histogram(aes(fill = cut), binwidth = 0.1, position = "fill",
    na.rm = TRUE) +
  theme(legend.position = "none") +
# density plot
ggplot(diamonds, aes(depth)) +
  geom_density(na.rm = TRUE) + 
  theme(legend.position = "none") +
# adjust binwidth
ggplot(diamonds, aes(depth)) + 
  geom_histogram(aes(fill = cut), binwidth = 0.2, position = "fill",
    na.rm = TRUE) +
  theme(legend.position = "none") +
# adjust = 1/2 means use half of the default bandwidth (more rough)
ggplot(diamonds, aes(depth)) +
  geom_density(na.rm = TRUE, adjust = 0.5) + 
  theme(legend.position = "none") +
# both fill and color can separate groups
ggplot(diamonds, aes(depth, fill = cut)) +
  geom_density(alpha = 0.2, na.rm = TRUE) + 
  theme(legend.position = "none") +
# apply layout and set common x axis
plot_layout(design = layout) & scale_x_continuous(limits = c(58, 68))
```

